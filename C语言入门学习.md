[TOC]

# 1.为什么选择C语言

![image-20210504113217987](https://i.loli.net/2021/05/04/qG8MCf3Bnh6irQI.png)

![image-20210504113538541](https://i.loli.net/2021/05/04/APblMaYwKzoNJH7.png)



![image-20210504113552578](https://i.loli.net/2021/05/04/HsWJo9bOk4ZhDYq.png)

![image-20210504113656579](https://i.loli.net/2021/05/04/N7szli9prE2UuW1.png)



#  2.第一个C语言程序



~~~ 
#include <stdio.h>
void main(){
printf("hello world\n");
}
~~~

# 3.基本数据类型

## 1.字符型、整型、浮点型所占内存的大小

![image-20210504114532034](https://i.loli.net/2021/05/04/vPmFEs5TXCk6KAl.png)

## 2.size of （）返回类型的字节数

![image-20210504114723918](https://i.loli.net/2021/05/04/65N8m3w2qXts4rz.png)



![image-20210504115058017](https://i.loli.net/2021/05/04/Nk6UdAWOmL4YH1D.png)



## 3.什么是字节、字符，一个字节等于多少位

- 字节byte：是一种数据量的单位，一个字节等于 8 位。0001 0001就是8位，等于1字节。所有的数据所占空间都可以用字节数来衡量。例如一个字符占 2 个字节，一个 int 占 4 个字节，一个 double 占 8 个字节

- 位bit:  1byte=8bit。例如0001就是四位

- 字符（char）：中文字符=2个字节，英文字符=1个字节

- 字母：一个占一个字节。

  

  ------

  中文字符：=两个字节=16位

  英文和数字字符：=一个字节8位

  字母：=一个字节8位。

  字符不等于字节（存在中文字符，与英文字符0。

1KB=1024B字节；1MB=1024KB=1024×1024B。

1B（byte，字节）= 8 （bit，位）；

1KB（Kilobyte，千字节）=1024B= 2^10 B；

## 4.数字、字符中0、\0、'0'、"0"的区别。

1. 0代表数字0，他不是字符，不需要ASCII来存储转换表示。

2. \0代表十进制ASCII 码为0（二进制ASCII 码为00000 0000）所表示的**NULL字符（空字符）**，是字符串结束的标志。

3. ‘0’代表十进制ASCII 码为48（二进制ASCII 码为0011 0000）的所表示的**字符**，即**字符0。**

4. "0"是字符串常量，字符串常量是由一对双引号括起的**字符序列**。例如：“CHINA”。

   

## 5.ASCII码

ASCII码表具体如下所示:

ascii代码用8位二进制表示一个字节（因为全是**英文字符**，所以一个字节就是一个字符）（1个中文字符等于2个字节=16位，1个英文字符等于1个字节=8位）。

| *<u>Bin(二进制) -ascii码</u>* | Oct(八进制) | Dec(十进制) | Hex(十六进制) | <u>*缩写/-对应字符*</u>     | 解释         |
| ----------------------------- | ----------- | ----------- | ------------- | --------------------------- | ------------ |
| 0000 0000                     | 00          | 0           | 0x00          | NULL(null)                  | 空字符       |
| 0000 0001                     | 01          | 1           | 0x01          | SOH(start of headline)      | 标题开始     |
| 0000 0010                     | 02          | 2           | 0x02          | STX (start of text)         | 正文开始     |
| 0000 0011                     | 03          | 3           | 0x03          | ETX (end of text)           | 正文结束     |
| 0000 0100                     | 04          | 4           | 0x04          | EOT (end of transmission)   | 传输结束     |
| 0000 0101                     | 05          | 5           | 0x05          | ENQ (enquiry)               | 请求         |
| 0000 0110                     | 06          | 6           | 0x06          | ACK (acknowledge)           | 收到通知     |
| 0000 0111                     | 07          | 7           | 0x07          | BEL (bell)                  | 响铃         |
| 0000 1000                     | 010         | 8           | 0x08          | BS (backspace)              | 退格         |
| 0000 1001                     | 011         | 9           | 0x09          | HT (horizontal tab)         | 水平制表符   |
| 0000 1010                     | 012         | 10          | 0x0A          | LF (NL line feed, new line) | 换行键       |
| 0000 1011                     | 013         | 11          | 0x0B          | VT (vertical tab)           | 垂直制表符   |
| 0000 1100                     | 014         | 12          | 0x0C          | FF (NP form feed, new page) | 换页键       |
| 0000 1101                     | 015         | 13          | 0x0D          | CR (carriage return)        | 回车键       |
| 0000 1110                     | 016         | 14          | 0x0E          | SO (shift out)              | 不用切换     |
| 0000 1111                     | 017         | 15          | 0x0F          | SI (shift in)               | 启用切换     |
| 0001 0000                     | 020         | 16          | 0x10          | DLE (data link escape)      | 数据链路转义 |
| 0001 0001                     | 021         | 17          | 0x11          | DC1 (device control 1)      | 设备控制1    |
| 0001 0010                     | 022         | 18          | 0x12          | DC2 (device control 2)      | 设备控制2    |
| 0001 0011                     | 023         | 19          | 0x13          | DC3 (device control 3)      | 设备控制3    |
| 0001 0100                     | 024         | 20          | 0x14          | DC4 (device control 4)      | 设备控制4    |
| 0001 0101                     | 025         | 21          | 0x15          | NAK (negative acknowledge)  | 拒绝接收     |
| 0001 0110                     | 026         | 22          | 0x16          | SYN (synchronous idle)      | 同步空闲     |
| 0001 0111                     | 027         | 23          | 0x17          | ETB (end of trans. block)   | 结束传输块   |
| 0001 1000                     | 030         | 24          | 0x18          | CAN (cancel)                | 取消         |
| 0001 1001                     | 031         | 25          | 0x19          | EM (end of medium)          | 媒介结束     |
| 0001 1010                     | 032         | 26          | 0x1A          | SUB (substitute)            | 代替         |
| 0001 1011                     | 033         | 27          | 0x1B          | ESC (escape)                | 换码(溢出)   |
| 0001 1100                     | 034         | 28          | 0x1C          | FS (file separator)         | 文件分隔符   |
| 0001 1101                     | 035         | 29          | 0x1D          | GS (group separator)        | 分组符       |
| 0001 1110                     | 036         | 30          | 0x1E          | RS (record separator)       | 记录分隔符   |
| 0001 1111                     | 037         | 31          | 0x1F          | US (unit separator)         | 单元分隔符   |
| 0010 0000                     | 040         | 32          | 0x20          | (space)                     | 空格         |
| 0010 0001                     | 041         | 33          | 0x21          | !                           | 叹号         |
| 0010 0010                     | 042         | 34          | 0x22          | "                           | 双引号       |
| 0010 0011                     | 043         | 35          | 0x23          | #                           | 井号         |
| 0010 0100                     | 044         | 36          | 0x24          | $                           | 美元符       |
| 0010 0101                     | 045         | 37          | 0x25          | %                           | 百分号       |
| 0010 0110                     | 046         | 38          | 0x26          | &                           | 和号         |
| 0010 0111                     | 047         | 39          | 0x27          | '                           | 闭单引号     |
| 0010 1000                     | 050         | 40          | 0x28          | (                           | 开括号       |
| 0010 1001                     | 051         | 41          | 0x29          | )                           | 闭括号       |
| 0010 1010                     | 052         | 42          | 0x2A          | *                           | 星号         |
| 0010 1011                     | 053         | 43          | 0x2B          | +                           | 加号         |
| 0010 1100                     | 054         | 44          | 0x2C          | ,                           | 逗号         |
| 0010 1101                     | 055         | 45          | 0x2D          | -                           | 减号/破折号  |
| 0010 1110                     | 056         | 46          | 0x2E          | .                           | 句号         |
| 0010 1111                     | 057         | 47          | 0x2F          | /                           | 斜杠         |
| 0011 0000                     | 060         | 48          | 0x30          | 0                           | 字符0        |
| 0011 0001                     | 061         | 49          | 0x31          | 1                           | 字符1        |
| 0011 0010                     | 062         | 50          | 0x32          | 2                           | 字符2        |
| 0011 0011                     | 063         | 51          | 0x33          | 3                           | 字符3        |
| 0011 0100                     | 064         | 52          | 0x34          | 4                           | 字符4        |
| 0011 0101                     | 065         | 53          | 0x35          | 5                           | 字符5        |
| 0011 0110                     | 066         | 54          | 0x36          | 6                           | 字符6        |
| 0011 0111                     | 067         | 55          | 0x37          | 7                           | 字符7        |
| 0011 1000                     | 070         | 56          | 0x38          | 8                           | 字符8        |
| 0011 1001                     | 071         | 57          | 0x39          | 9                           | 字符9        |
| 0011 1010                     | 072         | 58          | 0x3A          | :                           | 冒号         |
| 0011 1011                     | 073         | 59          | 0x3B          | ;                           | 分号         |
| 0011 1100                     | 074         | 60          | 0x3C          | <                           | 小于         |
| 0011 1101                     | 075         | 61          | 0x3D          | =                           | 等号         |
| 0011 1110                     | 076         | 62          | 0x3E          | >                           | 大于         |
| 0011 1111                     | 077         | 63          | 0x3F          | ?                           | 问号         |
| 0100 0000                     | 0100        | 64          | 0x40          | @                           | 电子邮件符号 |
| 0100 0001                     | 0101        | 65          | 0x41          | A                           | 大写字母A    |
| 0100 0010                     | 0102        | 66          | 0x42          | B                           | 大写字母B    |
| 0100 0011                     | 0103        | 67          | 0x43          | C                           | 大写字母C    |
| 0100 0100                     | 0104        | 68          | 0x44          | D                           | 大写字母D    |
| 0100 0101                     | 0105        | 69          | 0x45          | E                           | 大写字母E    |
| 0100 0110                     | 0106        | 70          | 0x46          | F                           | 大写字母F    |
| 0100 0111                     | 0107        | 71          | 0x47          | G                           | 大写字母G    |
| 0100 1000                     | 0110        | 72          | 0x48          | H                           | 大写字母H    |
| 0100 1001                     | 0111        | 73          | 0x49          | I                           | 大写字母I    |
| 01001010                      | 0112        | 74          | 0x4A          | J                           | 大写字母J    |
| 0100 1011                     | 0113        | 75          | 0x4B          | K                           | 大写字母K    |
| 0100 1100                     | 0114        | 76          | 0x4C          | L                           | 大写字母L    |
| 0100 1101                     | 0115        | 77          | 0x4D          | M                           | 大写字母M    |
| 0100 1110                     | 0116        | 78          | 0x4E          | N                           | 大写字母N    |
| 0100 1111                     | 0117        | 79          | 0x4F          | O                           | 大写字母O    |
| 0101 0000                     | 0120        | 80          | 0x50          | P                           | 大写字母P    |
| 0101 0001                     | 0121        | 81          | 0x51          | Q                           | 大写字母Q    |
| 0101 0010                     | 0122        | 82          | 0x52          | R                           | 大写字母R    |
| 0101 0011                     | 0123        | 83          | 0x53          | S                           | 大写字母S    |
| 0101 0100                     | 0124        | 84          | 0x54          | T                           | 大写字母T    |
| 0101 0101                     | 0125        | 85          | 0x55          | U                           | 大写字母U    |
| 0101 0110                     | 0126        | 86          | 0x56          | V                           | 大写字母V    |
| 0101 0111                     | 0127        | 87          | 0x57          | W                           | 大写字母W    |
| 0101 1000                     | 0130        | 88          | 0x58          | X                           | 大写字母X    |
| 0101 1001                     | 0131        | 89          | 0x59          | Y                           | 大写字母Y    |
| 0101 1010                     | 0132        | 90          | 0x5A          | Z                           | 大写字母Z    |
| 0101 1011                     | 0133        | 91          | 0x5B          | [                           | 开方括号     |
| 0101 1100                     | 0134        | 92          | 0x5C          | \                           | 反斜杠       |
| 0101 1101                     | 0135        | 93          | 0x5D          | ]                           | 闭方括号     |
| 0101 1110                     | 0136        | 94          | 0x5E          | ^                           | 脱字符       |
| 0101 1111                     | 0137        | 95          | 0x5F          | _                           | 下划线       |
| 0110 0000                     | 0140        | 96          | 0x60          | `                           | 开单引号     |
| 0110 0001                     | 0141        | 97          | 0x61          | a                           | 小写字母a    |
| 0110 0010                     | 0142        | 98          | 0x62          | b                           | 小写字母b    |
| 0110 0011                     | 0143        | 99          | 0x63          | c                           | 小写字母c    |
| 0110 0100                     | 0144        | 100         | 0x64          | d                           | 小写字母d    |
| 0110 0101                     | 0145        | 101         | 0x65          | e                           | 小写字母e    |
| 0110 0110                     | 0146        | 102         | 0x66          | f                           | 小写字母f    |
| 0110 0111                     | 0147        | 103         | 0x67          | g                           | 小写字母g    |
| 0110 1000                     | 0150        | 104         | 0x68          | h                           | 小写字母h    |
| 0110 1001                     | 0151        | 105         | 0x69          | i                           | 小写字母i    |
| 0110 1010                     | 0152        | 106         | 0x6A          | j                           | 小写字母j    |
| 0110 1011                     | 0153        | 107         | 0x6B          | k                           | 小写字母k    |
| 0110 1100                     | 0154        | 108         | 0x6C          | l                           | 小写字母l    |
| 0110 1101                     | 0155        | 109         | 0x6D          | m                           | 小写字母m    |
| 0110 1110                     | 0156        | 110         | 0x6E          | n                           | 小写字母n    |
| 0110 1111                     | 0157        | 111         | 0x6F          | o                           | 小写字母o    |
| 0111 0000                     | 0160        | 112         | 0x70          | p                           | 小写字母p    |
| 0111 0001                     | 0161        | 113         | 0x71          | q                           | 小写字母q    |
| 0111 0010                     | 0162        | 114         | 0x72          | r                           | 小写字母r    |
| 0111 0011                     | 0163        | 115         | 0x73          | s                           | 小写字母s    |
| 0111 0100                     | 0164        | 116         | 0x74          | t                           | 小写字母t    |
| 0111 0101                     | 0165        | 117         | 0x75          | u                           | 小写字母u    |
| 0111 0110                     | 0166        | 118         | 0x76          | v                           | 小写字母v    |
| 0111 0111                     | 0167        | 119         | 0x77          | w                           | 小写字母w    |
| 0111 1000                     | 0170        | 120         | 0x78          | x                           | 小写字母x    |
| 0111 1001                     | 0171        | 121         | 0x79          | y                           | 小写字母y    |
| 0111 1010                     | 0172        | 122         | 0x7A          | z                           | 小写字母z    |
| 0111 1011                     | 0173        | 123         | 0x7B          | {                           | 开花括号     |
| 0111 1100                     | 0174        | 124         | 0x7C          | \|                          | 垂线         |
| 0111 1101                     | 0175        | 125         | 0x7D          | }                           | 闭花括号     |
| 0111 1110                     | 0176        | 126         | 0x7E          | ~                           | 波浪号       |
| 0111 1111                     | 0177        | 127         | 0x7F          | DEL (delete)                | 删除         |



# 4.常量与变量

## 1.什么是常量？

顾名思义，表示一些固定的数据，不能改变的数据！

## 2.哪些是常量？

整型常量 	1、2、3、552、10000
字符常量 	'A'     'a'	'\0'	'M'
浮点型常量	1.23、3.14、0.345、

字符串常量	“6”、"哇哈哈”、“abcd”、"Hello World"

符号常量:		以用一个标识符来表示一个常量，称之为符号常量。	

​						#define PI 3.1415926

### **数字是数字，字符是字符，因为字符在C语言中不能表示，所以引入了ASCII码**

## 3.什么是变量？

顾名思义，表示数据是可以经常修改的！

![image-20210504145556236](https://i.loli.net/2021/05/04/SByT2HiG4q3CL7F.png)

## 4.变量的定义

变量类型	变量名；

int a；//整型变量

float b；//浮点型变量

char c；//字符型变量

## 5.变量名的取法？

1、变量名只能是字母（A-Z，a-z）和数字（0-9）或者下划线（_）组成。
2、第一个字母必须是字母或者下划线(_ _)开头。
3、不能使用**C关键字**来命名变量，以免冲突。
4、变量名区分大小写。
错误示例：123a 		int 				11

## 6.变量的初始化

变量类型	变量名=值；

int a=10；//初始化a为10
float b=0.23；//初始化b为0.23
char c='A'；//初始化c为A'

## 7.变量的赋值

变量名=值；

int a；//定义变量

aa=10；//把10赋给a

a=20；//把20赋给a

![image-20210504150600431](https://i.loli.net/2021/05/04/8IdRKDhe59tmMZo.png)

![image-20210504151010913](https://i.loli.net/2021/05/04/NelOiGqZ8dcoWPC.png)



![image-20210504151249984](https://i.loli.net/2021/05/04/JPj3tpsTRiSZCH4.png)

## 8.什么是字节、字符，一个字节等于多少位

- 字节byte：是一种数据量的单位，一个字节等于 8 位。0001 0001就是8位，等于1字节。所有的数据所占空间都可以用字节数来衡量。例如一个中文字符占 2 个字节，一个英文字符占 1 个字节，一个 int 占 4 个字节，一个 double 占 8 个字节

- 位bit:  1byte=8bit。例如0001就是四位

- 字符（char）：中文字符=2个字节，英文字符=1个字节

- 字母：一个占一个字节。

  

  ------

  中文字符：=两个字节=16位

  英文和数字字符：=一个字节8位

  字母：=一个字节8位。

  字符不等于字节（存在中文字符，与英文字符0。

1KB=1024B字节；1MB=1024KB=1024×1024B。

1B（byte，字节）= 8 （bit，位）；

1KB（Kilobyte，千字节）=1024B= 2^10 B；

## 9.数字、字符中0、\0、'0'、"0"的区别。

1. 0代表数字0，他不是字符，不需要ASCII来存储转换表示。
2. \0代表十进制ASCII 码为0（二进制ASCII 码为00000 0000）所表示的**NULL字符（空字符）**，是字符串结束的标志。
3. ‘0’代表十进制ASCII 码为48（二进制ASCII 码为0011 0000）的所表示的**字符**，即**字符0。**
4. "0"是字符串常量，字符串常量是由一对双引号括起的**字符序列**。例如：“CHINA”。

## 10.ASCII码

ASCII码表具体如下所示 [1] :

ascii代码用8位二进制表示一个字符。

| *<u>Bin(二进制) -ascii码</u>* | Oct(八进制) | Dec(十进制) | Hex(十六进制) | <u>*缩写/-对应字符*</u>     | 解释         |
| ----------------------------- | ----------- | ----------- | ------------- | --------------------------- | ------------ |
| 0000 0000                     | 00          | 0           | 0x00          | NULL(null)                  | 空字符       |
| 0000 0001                     | 01          | 1           | 0x01          | SOH(start of headline)      | 标题开始     |
| 0000 0010                     | 02          | 2           | 0x02          | STX (start of text)         | 正文开始     |
| 0000 0011                     | 03          | 3           | 0x03          | ETX (end of text)           | 正文结束     |
| 0000 0100                     | 04          | 4           | 0x04          | EOT (end of transmission)   | 传输结束     |
| 0000 0101                     | 05          | 5           | 0x05          | ENQ (enquiry)               | 请求         |
| 0000 0110                     | 06          | 6           | 0x06          | ACK (acknowledge)           | 收到通知     |
| 0000 0111                     | 07          | 7           | 0x07          | BEL (bell)                  | 响铃         |
| 0000 1000                     | 010         | 8           | 0x08          | BS (backspace)              | 退格         |
| 0000 1001                     | 011         | 9           | 0x09          | HT (horizontal tab)         | 水平制表符   |
| 0000 1010                     | 012         | 10          | 0x0A          | LF (NL line feed, new line) | 换行键       |
| 0000 1011                     | 013         | 11          | 0x0B          | VT (vertical tab)           | 垂直制表符   |
| 0000 1100                     | 014         | 12          | 0x0C          | FF (NP form feed, new page) | 换页键       |
| 0000 1101                     | 015         | 13          | 0x0D          | CR (carriage return)        | 回车键       |
| 0000 1110                     | 016         | 14          | 0x0E          | SO (shift out)              | 不用切换     |
| 0000 1111                     | 017         | 15          | 0x0F          | SI (shift in)               | 启用切换     |
| 0001 0000                     | 020         | 16          | 0x10          | DLE (data link escape)      | 数据链路转义 |
| 0001 0001                     | 021         | 17          | 0x11          | DC1 (device control 1)      | 设备控制1    |
| 0001 0010                     | 022         | 18          | 0x12          | DC2 (device control 2)      | 设备控制2    |
| 0001 0011                     | 023         | 19          | 0x13          | DC3 (device control 3)      | 设备控制3    |
| 0001 0100                     | 024         | 20          | 0x14          | DC4 (device control 4)      | 设备控制4    |
| 0001 0101                     | 025         | 21          | 0x15          | NAK (negative acknowledge)  | 拒绝接收     |
| 0001 0110                     | 026         | 22          | 0x16          | SYN (synchronous idle)      | 同步空闲     |
| 0001 0111                     | 027         | 23          | 0x17          | ETB (end of trans. block)   | 结束传输块   |
| 0001 1000                     | 030         | 24          | 0x18          | CAN (cancel)                | 取消         |
| 0001 1001                     | 031         | 25          | 0x19          | EM (end of medium)          | 媒介结束     |
| 0001 1010                     | 032         | 26          | 0x1A          | SUB (substitute)            | 代替         |
| 0001 1011                     | 033         | 27          | 0x1B          | ESC (escape)                | 换码(溢出)   |
| 0001 1100                     | 034         | 28          | 0x1C          | FS (file separator)         | 文件分隔符   |
| 0001 1101                     | 035         | 29          | 0x1D          | GS (group separator)        | 分组符       |
| 0001 1110                     | 036         | 30          | 0x1E          | RS (record separator)       | 记录分隔符   |
| 0001 1111                     | 037         | 31          | 0x1F          | US (unit separator)         | 单元分隔符   |
| 0010 0000                     | 040         | 32          | 0x20          | (space)                     | 空格         |
| 0010 0001                     | 041         | 33          | 0x21          | !                           | 叹号         |
| 0010 0010                     | 042         | 34          | 0x22          | "                           | 双引号       |
| 0010 0011                     | 043         | 35          | 0x23          | #                           | 井号         |
| 0010 0100                     | 044         | 36          | 0x24          | $                           | 美元符       |
| 0010 0101                     | 045         | 37          | 0x25          | %                           | 百分号       |
| 0010 0110                     | 046         | 38          | 0x26          | &                           | 和号         |
| 0010 0111                     | 047         | 39          | 0x27          | '                           | 闭单引号     |
| 0010 1000                     | 050         | 40          | 0x28          | (                           | 开括号       |
| 0010 1001                     | 051         | 41          | 0x29          | )                           | 闭括号       |
| 0010 1010                     | 052         | 42          | 0x2A          | *                           | 星号         |
| 0010 1011                     | 053         | 43          | 0x2B          | +                           | 加号         |
| 0010 1100                     | 054         | 44          | 0x2C          | ,                           | 逗号         |
| 0010 1101                     | 055         | 45          | 0x2D          | -                           | 减号/破折号  |
| 0010 1110                     | 056         | 46          | 0x2E          | .                           | 句号         |
| 0010 1111                     | 057         | 47          | 0x2F          | /                           | 斜杠         |
| 0011 0000                     | 060         | 48          | 0x30          | 0                           | 字符0        |
| 0011 0001                     | 061         | 49          | 0x31          | 1                           | 字符1        |
| 0011 0010                     | 062         | 50          | 0x32          | 2                           | 字符2        |
| 0011 0011                     | 063         | 51          | 0x33          | 3                           | 字符3        |
| 0011 0100                     | 064         | 52          | 0x34          | 4                           | 字符4        |
| 0011 0101                     | 065         | 53          | 0x35          | 5                           | 字符5        |
| 0011 0110                     | 066         | 54          | 0x36          | 6                           | 字符6        |
| 0011 0111                     | 067         | 55          | 0x37          | 7                           | 字符7        |
| 0011 1000                     | 070         | 56          | 0x38          | 8                           | 字符8        |
| 0011 1001                     | 071         | 57          | 0x39          | 9                           | 字符9        |
| 0011 1010                     | 072         | 58          | 0x3A          | :                           | 冒号         |
| 0011 1011                     | 073         | 59          | 0x3B          | ;                           | 分号         |
| 0011 1100                     | 074         | 60          | 0x3C          | <                           | 小于         |
| 0011 1101                     | 075         | 61          | 0x3D          | =                           | 等号         |
| 0011 1110                     | 076         | 62          | 0x3E          | >                           | 大于         |
| 0011 1111                     | 077         | 63          | 0x3F          | ?                           | 问号         |
| 0100 0000                     | 0100        | 64          | 0x40          | @                           | 电子邮件符号 |
| 0100 0001                     | 0101        | 65          | 0x41          | A                           | 大写字母A    |
| 0100 0010                     | 0102        | 66          | 0x42          | B                           | 大写字母B    |
| 0100 0011                     | 0103        | 67          | 0x43          | C                           | 大写字母C    |
| 0100 0100                     | 0104        | 68          | 0x44          | D                           | 大写字母D    |
| 0100 0101                     | 0105        | 69          | 0x45          | E                           | 大写字母E    |
| 0100 0110                     | 0106        | 70          | 0x46          | F                           | 大写字母F    |
| 0100 0111                     | 0107        | 71          | 0x47          | G                           | 大写字母G    |
| 0100 1000                     | 0110        | 72          | 0x48          | H                           | 大写字母H    |
| 0100 1001                     | 0111        | 73          | 0x49          | I                           | 大写字母I    |
| 01001010                      | 0112        | 74          | 0x4A          | J                           | 大写字母J    |
| 0100 1011                     | 0113        | 75          | 0x4B          | K                           | 大写字母K    |
| 0100 1100                     | 0114        | 76          | 0x4C          | L                           | 大写字母L    |
| 0100 1101                     | 0115        | 77          | 0x4D          | M                           | 大写字母M    |
| 0100 1110                     | 0116        | 78          | 0x4E          | N                           | 大写字母N    |
| 0100 1111                     | 0117        | 79          | 0x4F          | O                           | 大写字母O    |
| 0101 0000                     | 0120        | 80          | 0x50          | P                           | 大写字母P    |
| 0101 0001                     | 0121        | 81          | 0x51          | Q                           | 大写字母Q    |
| 0101 0010                     | 0122        | 82          | 0x52          | R                           | 大写字母R    |
| 0101 0011                     | 0123        | 83          | 0x53          | S                           | 大写字母S    |
| 0101 0100                     | 0124        | 84          | 0x54          | T                           | 大写字母T    |
| 0101 0101                     | 0125        | 85          | 0x55          | U                           | 大写字母U    |
| 0101 0110                     | 0126        | 86          | 0x56          | V                           | 大写字母V    |
| 0101 0111                     | 0127        | 87          | 0x57          | W                           | 大写字母W    |
| 0101 1000                     | 0130        | 88          | 0x58          | X                           | 大写字母X    |
| 0101 1001                     | 0131        | 89          | 0x59          | Y                           | 大写字母Y    |
| 0101 1010                     | 0132        | 90          | 0x5A          | Z                           | 大写字母Z    |
| 0101 1011                     | 0133        | 91          | 0x5B          | [                           | 开方括号     |
| 0101 1100                     | 0134        | 92          | 0x5C          | \                           | 反斜杠       |
| 0101 1101                     | 0135        | 93          | 0x5D          | ]                           | 闭方括号     |
| 0101 1110                     | 0136        | 94          | 0x5E          | ^                           | 脱字符       |
| 0101 1111                     | 0137        | 95          | 0x5F          | _                           | 下划线       |
| 0110 0000                     | 0140        | 96          | 0x60          | `                           | 开单引号     |
| 0110 0001                     | 0141        | 97          | 0x61          | a                           | 小写字母a    |
| 0110 0010                     | 0142        | 98          | 0x62          | b                           | 小写字母b    |
| 0110 0011                     | 0143        | 99          | 0x63          | c                           | 小写字母c    |
| 0110 0100                     | 0144        | 100         | 0x64          | d                           | 小写字母d    |
| 0110 0101                     | 0145        | 101         | 0x65          | e                           | 小写字母e    |
| 0110 0110                     | 0146        | 102         | 0x66          | f                           | 小写字母f    |
| 0110 0111                     | 0147        | 103         | 0x67          | g                           | 小写字母g    |
| 0110 1000                     | 0150        | 104         | 0x68          | h                           | 小写字母h    |
| 0110 1001                     | 0151        | 105         | 0x69          | i                           | 小写字母i    |
| 0110 1010                     | 0152        | 106         | 0x6A          | j                           | 小写字母j    |
| 0110 1011                     | 0153        | 107         | 0x6B          | k                           | 小写字母k    |
| 0110 1100                     | 0154        | 108         | 0x6C          | l                           | 小写字母l    |
| 0110 1101                     | 0155        | 109         | 0x6D          | m                           | 小写字母m    |
| 0110 1110                     | 0156        | 110         | 0x6E          | n                           | 小写字母n    |
| 0110 1111                     | 0157        | 111         | 0x6F          | o                           | 小写字母o    |
| 0111 0000                     | 0160        | 112         | 0x70          | p                           | 小写字母p    |
| 0111 0001                     | 0161        | 113         | 0x71          | q                           | 小写字母q    |
| 0111 0010                     | 0162        | 114         | 0x72          | r                           | 小写字母r    |
| 0111 0011                     | 0163        | 115         | 0x73          | s                           | 小写字母s    |
| 0111 0100                     | 0164        | 116         | 0x74          | t                           | 小写字母t    |
| 0111 0101                     | 0165        | 117         | 0x75          | u                           | 小写字母u    |
| 0111 0110                     | 0166        | 118         | 0x76          | v                           | 小写字母v    |
| 0111 0111                     | 0167        | 119         | 0x77          | w                           | 小写字母w    |
| 0111 1000                     | 0170        | 120         | 0x78          | x                           | 小写字母x    |
| 0111 1001                     | 0171        | 121         | 0x79          | y                           | 小写字母y    |
| 0111 1010                     | 0172        | 122         | 0x7A          | z                           | 小写字母z    |
| 0111 1011                     | 0173        | 123         | 0x7B          | {                           | 开花括号     |
| 0111 1100                     | 0174        | 124         | 0x7C          | \|                          | 垂线         |
| 0111 1101                     | 0175        | 125         | 0x7D          | }                           | 闭花括号     |
| 0111 1110                     | 0176        | 126         | 0x7E          | ~                           | 波浪号       |
| 0111 1111                     | 0177        | 127         | 0x7F          | DEL (delete)                | 删除         |



# 5.进制转换

1.什么是进制？
进制也就是进位制，是人们规定的一种进位方法。对于任何一种进制：N进制，就表示某一位置上的数运算时是逢N进一位，每一位上不可能存在N。

2.机器的语言
计算机为什么只认识二进制，为什么只认识1和0？
因为电路中容易实现，二进制数码只有两个（“0”和“1”）。电路只要能识别低、高就可以表示“0”和“1”。

![image-20210504151532977](https://i.loli.net/2021/05/04/QCim4GzjRe6HBfN.png)

当我们用一个开关来控制一盏灯时，它有两个状态，一个是开，一个是关，我们用1代表开，用0代表关。用两个开关控制两盏灯呢？两个都关、就有四种状态，即00、01、10、11。三个开关呢……大量的“开关”变成了强大的计算机！！

3.十进制（常用）
逢十进一：
09+01=10
08+03=11
十进制的每一位数不可能大于10

二进制
逢二进一：
01+01=10
11+01=100
二进制的每一位数不可能大于2

十六进制
逢十六进一：
08+08=10
**08+0A=12**
（注：a-f分别代表10-15）
十六进制的每一位数不可能大于16

4.C语言进制的表示方法

![image-20210504152020802](https://i.loli.net/2021/05/04/UJzjH7ICA1ye6Ts.png)

![image-20210504152242059](https://i.loli.net/2021/05/04/XUyhm8OSdvuC9oI.png)

~~~
#include "stdio.h"
void main()
{
//前缀不一样，代表的进制不一样，二进制没办法表示
printf（"%d\n"，10000）；//默认是十进制
printf（"%d\n"，010）；//八进制，用0打头
printf（"%d\n"，0x10）；//十六进制，用0x
}
输出结果：
10000
8
16
~~~

5.进制转换及计算

## 1.十进制转换成其他进制

![image-20210504152511944](https://i.loli.net/2021/05/04/9nNqwbvZVoBRuhz.png)

**HEX  十六进制**
**DEC  十进制	decimal**
**OCT  八进制	octal**
**BIN   二进制	binary**

![image-20210504152901950](https://i.loli.net/2021/05/04/78Upr4GF1K5oRxP.png)

![image-20210504153154603](https://i.loli.net/2021/05/04/CORb21PnZmdjafr.png)

![image-20210504153203822](https://i.loli.net/2021/05/04/r5MwixJQBzhq1Ho.png)

## 2.其他进制转换成十进制


![image-20210504153249446](https://i.loli.net/2021/05/04/UzHMsa2cXpJmeN3.png)

![image-20210504153520763](https://i.loli.net/2021/05/04/KCSM2FP4sHTL5ri.png)

![image-20210504153534295](https://i.loli.net/2021/05/04/INT2uzPi3ZnqR9X.png)

## 3.二进制带小数点==》八进制----三个等于一个 7-8

![image-20210504160041295](https://i.loli.net/2021/05/04/KldGsoXu6xFWqfA.png)

## 4.八进制转换成二进制----三个等于一个 7-8



![image-20210504160255326](https://i.loli.net/2021/05/04/YZRAdnLjprbQc3F.png)



## 5.二进制转十六进制----四个等于一个 15-16

![image-20210504160350351](https://i.loli.net/2021/05/04/pm7aVK25TGjtxoU.png)

##  6.十六进制转二进制----一个等于四个



![image-20210504170239988](https://i.loli.net/2021/05/04/xHYJAMPFwfvB3ns.png)

## 7.八进制转十六进制---一个对三个（先转换成二进制）--->四个对一个

![image-20210504170339107](https://i.loli.net/2021/05/04/xnqYMWBhcPf6s5u.png)

## 8.十六进制转八进制

![image-20210504170426071](https://i.loli.net/2021/05/04/68K4tbf5ucjsgzB.png)

## 9.代码的实现

![image-20210504170514933](https://i.loli.net/2021/05/04/NDnFdSacReVxro4.png)

~~~
∥用代码展示进制转换
int a=215；
printf（"十进制%d\n"，a）；
printf（"八进制%o\n"，a）；
printf（"十六进制%x %X %p\n"，a，a，a）；//小写展示，大写，以地址形式展示
char s[10]；
itoa（a，s，2）；//函数，转为二进制
printf（（"二进制%s\n"，s）；//string，以字符串的形式打印
~~~



![image-20210504170850953](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504171403.png)

# 6.表达式与运算符

## 表达式





![image-20210504171530265](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504171530.png)



什么是表达式？
C=4+21							操作符（operators）
a=（b+c）/d 				  操作数（operands）

通俗理解为小学的算数题目！

![image-20210504212609336](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504212609.png)

![image-20210504212646374](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504212646.png)



![image-20210504212944638](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504212944.png)

![image-20210504213029185](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504213029.png)

## 运算符

![image-20210504213442107](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504213442.png)



![image-20210504213459587](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504213520.png)

![image-20210504213729192](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504213729.png)

将printf（"%%=：%d\n"，c%=100）；%%就能打印%了

## C语言的真假观

![image-20210504213838353](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504213838.png)

## 关系运算符

![image-20210504214108719](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504214108.png)

## 逻辑运算符

![image-20210504214119833](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504214119.png)

![image-20210504214135171](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504214135.png)

## 位运算符

![image-20210504214207529](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504214207.png)

## 逻辑位运算符



![image-20210504214252792](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504214252.png)

**逻辑位运算符规则**

- A&B	对应位上全为1、则为1，否则为0
- AlB      对应位上全为0、则为0，否则为1
- A^B       对应位上相异为1，否则为0
- ~A       对应位上1转为0，0转为1
- A<<N  A向左移动N位数，右补0。
- A>>N  A向右移动N位数，左补0，右舍弃。

![image-20210504215039115](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504215039.png)

~~~
输出值为
0
3
3
-2  ~是数值取反-2
4
1
~~~

**简便适合人类运算的计算方法：**
<u>**如对a按位取反，则得到的结果为-（a+1）**</u>
**此条运算方式对正数负数和零都适用。**

![img](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504220409.png)

## 自增自减运算符

![image-20210504220604643](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504220604.png)

~~~
9
8
9
~~~

![image-20210504220637995](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504220638.png)

## 三目运算符



![image-20210504220647437](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504220647.png)

~~~
//三目运算符
printf（"三目运算%d\n"，1？1000：2000）；
printf（"三目运算%d\n"，0？1000：2000）；

1000
2000
~~~

## 例题

![image-20210504220929796](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504220929.png)



tips：禁止在项目代码中写出上述表达式、如果一定需要写这样的表达式、请用圆括号括弧你的每一步、哪怕你非常清楚运算符的优先级。

![image-20210504221031561](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504221031.png)

# 7.printf与scanf函数

## 1.什么是printf？

printf（）函数是标准库提供的一个最常用的格式化输出打印函数！![image-20210504221840269](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504221840.png)

![image-20210504221735349](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504221735.png)

## 2.什么是scanf？

scanf（）函数是标准库提供的一个最常用的格式化输入函数！

![image-20210504221816427](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504221816.png)

![image-20210504221915860](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504221915.png)

## 3.最常用的格式输出符

![image-20210504222046565](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504222046.png)



%c一个字符
%d有符号十进制整数
%f浮点数、十进制记数法
%i有符号十进制数（与%d相同）
%o无符号八进制整数
%p指针
%s字符串
%x使用十六进制数字Of的无符号十六进制整数
%X使用十六进制数字Of的无符号十六进制整数

## 4.为什么c语言里，scanf函数里的变量要取地址，printf不要呢？

printf是输出，所以只需要值，不需要指针。

scanf是输入，输入是把键入的数据保存到进程内的一个变量中，而变量需要一个索引(应该是唯一的)来标识，这个索引就是指针，形如*p这样的。

## 5.为什么C语言Scanf函数对字符串不要加 取地址运算符&

**C语言的字符串为数组形式，而数组的名称可以表示其地址**，故对字符串输入不需要加地址符。**而单独的字符、整型变量等的名称不能直接表示地址，故需要加地址符**。

数组名就代表了该数组的地址。整个数组是一块连续的内存单元，数组名所代表的地址为第0个元素的地址，c就代表c[0]的地址。

设数组c的首地址为0X2000，也就是说c[0]地址为0X2000，则数组名c就代表这个首地址。因为c已经表示地址，所以在c前面不能再加取地址符&。

[![img](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210509204550.png)](https://iknow-pic.cdn.bcebos.com/7acb0a46f21fbe09b5e5ae7164600c338744ad18)

字符串数据类型是建模在形式字符串的想法上的数据类型。字符串是几乎在所有编程语言中可以实现的非常重要和有用的数据类型。

**扩展资料**

为了避免这种情况，可多设几个字符数组分段存放含空格的串。程序可改写如下：

\#include<stdio.h>

intmain()

{

char str1[20], str2[20], str3[20];

printf("Input string: ");

scanf("%s %s %s %s",str1,str2, str3);

printf("Your string: %s %s %s %s\n",str1, str2, str3);

}

运行结果：

Input string: C C++ Java

Your string: C C++ Java

//空字符，自动读取下一个字符

​	C语言的字符串实际上是 字符数组.既然是数组, 那么数组头自然是一个指针.char str[] = {“abc”};这个str实际上是一个不可变的字符指针.scanf的参数要求传入指针. 之后按照格式化字符串对指针指向的地址赋值…str本身就是一个指针了, 所以不需要&str,如果&str, 那么得到是就是指针的指针,scanf并不只是对字符串不加 取地址运算符.例如 int arr[] = {1, 2, 3};scanf("%d", arr);这里对arr照样不需要取地址运算符, 因为arr是数组头, 本身就是一个指针.上面的语句是对arr数组的第一个元素赋值, 就是arr[0];当然也可以这么写.scanf("%d", &arr[0]);arr[0]是一个值, 并非指针, 于是对其取地址.对于字符串也可以这么写.
​	char str[3] ;

​	scanf("%c", &str[0]);//str的第一个元素赋值也就是 str[0];

# 8.选择结构

![image-20210504222220707](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504222220.png)

选择结构分为if-else结构与switch-case结构。

## if-else结构

![image-20210504222257371](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504222257.png)

![image-20210504222313993](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504222314.png)

![image-20210504222327345](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504222327.png)

![image-20210504222350237](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504222350.png)

## switch case语句

![image-20210504222455594](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504222455.png)

## 总结

![image-20210504222538316](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504222538.png)

# 9.循环结构

循环结构的分类

- for
- while
- do-while

![image-20210504222653387](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504222653.png)

![image-20210504222704635](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504222704.png)

![image-20210504222728674](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504222728.png)

例题：计算1到100相加的值

## for 循环

~~~
#include <stdio.h>
void main（）
{
int sum=0；
for（int i=1；i<=100；++i）//没有++i，则条件一直为真，那么死循环sum+=i；
	{
	sum=sum +i；
	}
printf（"for %d\n"，sum）；
}


5050
~~~

## while 循环

~~~
sum=0；
int j=1；
while（j<=100）
{
sum+=j；
++j；//不能忘记，改变条件状态，否则就是死循环
}
printf（"while%d\n"，sum）；
~~~

## do-while循环

~~~
sum=0；
int k=1；
do 
{
sum+=k；
++k；
}while（k<=100）；

printf（"do while%d\n"，sum）；
~~~

![image-20210504223346260](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504223346.png)

### 总结

![image-20210504223517426](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504223517.png)

# 10.跳出语句 break、continue、goto关键字！

在循环中，我们可能会触发某个条件而跳出某次循环或者终止循环！

## break--**break结束整个循环体！（一层）**

**break结束整个循环体！（一层）**

![image-20210504223749151](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504223749.png)

![image-20210504223731265](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504223731.png)

## continue--结束单次循环！（一层）

结束单次循环！（一层）

![image-20210504223920265](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504223920.png)

![image-20210504223913126](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504223913.png)

## goto--**跳转到loop的位置！（多层）**

loop：
	语句
goto loop；

**跳转到loop的位置！（多层）**

~~~
//goto loop语句
for（int i=0；i<10；++i）
{
//当i==4的时候，跳转
	if（i==4）
	{
		goto loop；
	}
printf("%d ",i);
}
loop
/跳转到loop的位置
~~~



![image-20210504224147019](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504224147.png)



====================================死循环示例=======================================



![image-20210504224414796](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504224414.png)

![image-20210504224402992](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504224403.png)

//goto loop语句，太强大，不太建议便用，因为会影响程序的可读性

## 总结

![image-20210504224550239](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504224550.png)

## goto跳出多层循环体--示例

多层循环场景

~~~
for(int j=0;j<10;j++)
{
printf("\n%d---->",j);
	for(int k=0;k<10;k++)
	{	
		printf("%d ",k);
	}
}
~~~





![image-20210504224708250](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504224708.png)

 ~~~
for(int j=0;j<10;j++)
{
printf("\n%d---->",j);
	for(int k=0;k<10;k++)
	{	
		if(k==2)
		{
			break;
		}
		printf("%d ",k);
	}
}
 ~~~

![image-20210504224944724](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504224944.png)

### break 缺点：只能跳出一层循环

~~~
for(int j=0;j<10;j++)
{
printf("\n%d---->",j);
	for(int k=0;k<10;k++)
	{	
		if(k==2)
		{
			continue;
		}
		printf("%d ",k);
	}
}
~~~

![image-20210504225130920](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504225130.png)

### continue 缺点：结束单次循环，其他满足条件的循环继续

~~~
for(int j=0;j<10;j++)
{
printf("\n%d---->",j);
	for(int k=0;k<10;k++)
	{	
		if(k==2)
		{
			goto loop;
		}
		printf("%d ",k);
	}
}
loop
~~~

![image-20210504225319394](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210504225319.png)

### goto loop优点 :实现多层循环体跳出

# 11.一维数组

存放一堆相同类型数据的好办法！

数组的概念
存储一个固定大小的相同类型元素的顺序集合

## **数组的初始化**
int arr[3]=**{1，2，3}；**

## **数组的赋值**
int arr[3]；

arr[0]= 1；

arr[1]=2；

arr[2]=3；

![image-20210505095618189](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505100120.png)

## **数组的引用**
ar[0]代表第1个元素
ar[1]代表第2个元素
ar[N]代表第N+1个元素

## 数组的遍历--下标索引从0开始
~~~
//数组的遍历
for（int i=0；i<3；++i）
{
printf（"%d”，arr[i]）；
}
~~~

**打印数组内元素的地址**

~~~
for（int i=0；i<3；++i）//正好数组的下标就是从0开始的
{
printf（"%p"，&arr[i]）；//打印每个元素的起始地址，看一下是否连续
}
~~~

![image-20210505100146546](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505100146.png)

这三个地址之间相差为4，而整数int的占四个字节（32位），===》内存是连续的

# 12.二维数组

相当于一个N行M列表格来存放数据！

![image-20210505100416465](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505100416.png)

![image-20210505100439945](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505100440.png)

![image-20210505100508959](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505100509.png)

## 二维数组的概念
二维数组本质上是以数组作为元素的数组，即“数组的数组”

## 数组的定义
类型	数组名	[长度1]	[长度2]
int 	nums		[1000]	[5]；

## 数组的初始化
int arr [2] [3]={{1，2，3}，{4，5，6}}；

## 数组的赋值
~~~
//数组的赋值
int arr[2][3]；
arr[0][0]=1；arr[1][0]=4；
arr[0][1]=2；arr[1][1]=5；
arr[0][2]=3；arr[1][2]=6；
~~~

![image-20210505100856470](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505100856.png)

## 数组的引用
~~~
数组的引用
arr[0][0]代表第1行第1列个元素
arr[0][1]代表第1行第2列个元素
arr[M][N]代表第M+1行第N+1列个元素
~~~

## 数组的遍历

![image-20210505101024225](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505101024.png)

## 数组的优点

二维数组是逻辑上二维结构，数组的内存是连续的，可以通过下标索引访问，**随机访问**效率高！

# 13.字符数组-----一个”HelloWorld”字符串就是一个字符数组！

**一个”HelloWorld”字符串就是一个字符数组！**

**参照整型数组，那么字符数组？**
int arr[3]；

char str[3]；

## 字符数组的概念

每个元素类型是字符的数组！

## 字符数组的初始化
### 方式一---》写成字符数组形式，里面元素是单个字符

char str[5]={‘h'，e'，'l'，'l'，‘o'}；

### 方式二---》写成字符串形式

char str[5]="hello”；

### 切记：字符串“hello”不是5个字符、而是6个，未尾还有一个\0'

### 代码演示

~~~
#include <stdio.h>

void main（）
{
//第一种初始化方式
char str[5]={'H'，'e'，'l'，'l'，'o'}；//这里有五个元素

//第二种初始化方式
char str2[5]="hello"；//字符串，实际上未尾还有一个隐藏的字符'\0'，系统自动添加

//第三种初始化方式
//先定义，再赋值
char str3[5];
str3[0]='h'; 
str3[1]='e'; 
str3[2]='1'; 
str3[3]='1'; 
str3[4]='o';

}
~~~

## 字符数组的引用

str[0]代表第1个字符元素
str[1]代表第2个字符元素
str[N]代表第N+1个字符元素

## 字符数组的遍历

### 遍历方式一

~~~
for（int i=0；i<5；++i）
{
printf（“%c”，str[i]）；
}
~~~

### 遍历方式二

字符数组的另一种遍历，当做字符串来输出，唯一要求是数组最后一个元素必须是\0

~~~
str[4]=\0'；//需要当成字符串输出时加'\0'
printf（“%s”，str）；
~~~

~~~
//str[5]={'H'，'e'，'l'，'l'，'o'}


//先输出字符串，"hello"字符串里面自动包含'\0'
printf（"%s\n"，"hello"）；//C语言以\0’为字符串的结束符


printf（"%s\n"，str）；//输出字符数组，因为我们的字符数组没有\0'结束符，
						//所以呢，会一直往后寻找，打印出乱码
~~~

![image-20210505103301574](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505103301.png)

**<u>代码修正</u>**

~~~
//所以呢，如果我们想以%s形式输出，数组最后一个元素必须是'\0'
char str4[6]={'h'，

'e，'l'，'l'，'o'，'\0"]；//6个元素
printf("%s\n",str4);
~~~

 

![image-20210505103650978](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505103651.png)

## 字符数组和字符串的区别

![image-20210505103705413](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505103705.png)



# 14.函数

模块化的第一步

一段求和的代码

~~~
int a=2；
int b=3；
int c=a+b；
printf（"%d"，c）；
~~~

![image-20210505104106005](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505104106.png)

![image-20210505104130168](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505104130.png)

## 函数的定义

函数（Function）是一段可以重复使用的代码！返回类型函数名（参数1，参数2..参数N）函数体；return XXX；

## 函数的形式

返回类型	函数名（参数1，参数2..参数N）

{

函数体；

return XXX；

}

**<u>示例</u>**

~~~
求和函数
int sum（int a，int b）
{
	int c=a+b；
	return c；
}

~~~

![image-20210505104421343](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505104421.png)

## 函数的调用

函数名（参数1，参数2）；

例如：sum（3，8）；

![image-20210505104531768](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505104531.png)

 ## 函数的分类

### 系统函数：
系统给我们提供的优秀的函数、直接使用即可，例如printf、scanf函数等。

### 自定义函数：
用户自己写的函数，例如sum；

## C程序的入口---main也是一个函数

~~~
void main（）
{
......
}
~~~

![image-20210505104838066](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505104838.png)

~~~
#include  <stdio.h>//系统头文件，包含了printf，scanf等函数的声明

void main()/系统主函数，整个程序的入口函数，这个是它的简写
{


}
~~~

## 运行示例

### 源文件 014.c

~~~
#include  <stdio.h>//系统头文件，包含了printf，scanf等函数的声明
#include "014.h"   //自定义函数的头文件，包含sum的声明

void main()/系统主函数，整个程序的入口函数，这个是它的简写
{
//调用sum函数
int c=sum(100,200);
printf("%d",c);

}

//sum 函数的实现
int sum(int a,int b)
{
return a+b;
}
~~~

### 头文件014.h

~~~
//sum 函数的声明
int sum (int a,int b);
~~~

## 系统常见头文件

![image-20210505105600786](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505105600.png)

## 函数的优点

>使程序变得更简洁、可读性好
>有利于程序维护
>提高了代码的重用性

# 15.函数递归

递归中一定有个if语句来结束递归！

## 什么是函数递归

![image-20210505105753497](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505105753.png)

函数递归=自我调用+终结条件

~~~
返回类型	函数名（参数）
{
	if（终结条件）
	{
		终结条件；
	}
	else
	{
		函数名（参数）；
	}
}
~~~

## 示例：求1到100的总和的递归函数？--递归求解

~~~
015.c

#include <stdio.h> //系统头文件，包含了printf，scanf等系统函数的声明

//求和1至n的累加和，用递归的方式实现
int NFun（int n）
{
	//思路：如果N=3，3+NFun（2），如果N=2，2+NFun（1），如果N=1，NFun（1）=1
	//终结条件
	if（n==1）
	{
    	return 1；
    }
	else
	{
		return n+NFun(n-1);//自我调用
	}
}



void main()	///系统主函数，整个程序的入口函数，这个是它的简写
{
	int sum =NFun(100);
	printf("%d",sum)
}


~~~

## 递归的优缺点

递归的优点：使程序变得更简洁递归的

缺点：由于递归需要系统堆栈，所以空间消耗要比非递归代码要大很多。

# 16.变量的生命周期

变量和人一样也有寿命的，有的长，有的短！

## 什么是全局变量？
在函数外定义的变量叫做外部变量！

**作用域**：所有的源文件

**生命周期**：程序运行期一直存在

## 什么是局部变量？
在函数内定义的变量是局部变量！

**作用域：**仅限于函数内

**生命周期**：超出作用域马上销毁

![image-20210505113102698](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505113102.png)

~~~
void main（）
{
	int a=2；//局部变量
	{
		int b=0；//局部变量
		a=5；
		b=2；
	}//b=2销毁
	a=7；
}//a=2销毁
~~~

~~~
int sum（int a，int b）//a，b局部变量
{
	int c=a+b；//c局部变量
	return c；
}//a、b、c销毁
~~~

~~~
#include<stdio.h>
int g=20；//全局变量
void main（）
{
	g=100；
	printf（“%d"，g）；
	int g=20；//局部变量，屏蔽了全局变量
	printf（“%d”，g）；
}
~~~

# 17.内存管理

分配内存的一些函数

## 内存分类---形式1
C语言程序内存空间主要由五个部分组成：
代码段（.text）
数据段（.data）
BSS段（.bss）
**栈区（heap）**
**堆区（stack）**

### 1.代码区
由**编译器**分配、存放程序执行代码的一块内存区域。

### 2.全局数据区
由**编译器**分配、存放全局变量、静态变量、常量，只初始化一次。

### 3.BSS段
由**编译器**分配、是指用来存放程序中未初始化**（定义了一个变量，但是没有赋值）**的全局变量和静态变量。

BSS段（bss segment）通常是指用来存放程序中未初始化的全局变量的一块内存区域。

### 4.栈区
由**编译器**自动分配释放，存放函数的参数值、局部变量的值等。

### 5.堆区
由**程序员**分配和释放，若程序员不释放，程序结束时有可能由OS回收。

### 堆与栈的区别

![image-20210505114450269](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505114450.png)

## 内存分类---形式2

### 1.代码区

主要存储程序代码指令，define定义的常量。

### 2.数据区

 主要存储全局变量（常量），静态变量（常量），常量字符串。

### 3.栈区

 主要存储局部变量，栈区上的内容只在函数范围内存在，当函数运行结束，这些内容也会自动被销毁。其特点是效率高，但内存大小有限。

### 4.堆区

 由malloc,calloc分配的内存区域，其生命周期由free决定。堆的内存大小是由程序员分配的，理论上可以占据系统中的所有内存。

如下图所示：

![img](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505192729.png)

下面来看看一段代码，各个参量都存储在什么区域，

![img](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505192742.png)

## 内存分配的函数

![image-20210505115019098](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505115019.png)

## 内存释放的函数

![image-20210505115119779](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505115119.png)

## 示例



~~~

#include <stdio.h>//系统头文件，包含了printf，scanf等系统函数的声明
#include <stdlib.h>//系统头文件，包含了malloc，free等函数

int g=100；//全局数据区，一般存放全局变量，静态变量，常量
void main()//系统主函数，整个程序的入口函数，这个是它的简写
{

int a=10；//栈区，局部变量，函数参数

static int b=10；//哪怕是在函数体内，依然在全局数据区，只初始化一次
 
char str[]="hello"；//"hello"是常量、在全局数据区，但是str在栈区

//程序员手动分配4个字节的内存空间，首地址给p 
int *p=（int*）malloc（4）；//堆内存

//程序员手动释放堆内存
free（p）；

}

~~~

![image-20210505115952170](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505115952.png)

# 18.指针

## 什么是指针？

指针是一种地址值！
例如：0x 0000 12ea

## 什么是指针类型？

指针类型是一种类型！
格式：	**类型 ***

~~~
int		*		整型指针类型
char	*		字符型指针类型
float	*		浮点型指针类型
~~~

## 什么是指针变量？

顾名思义，用指针类型定义的变量就是指针变量！

![image-20210505120523460](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505120523.png)

## 如何定义指针变量？

指针类型	变量名；

int 				* a；			//定义一个整型指针变量

char 			 * b；			//定义一个字符型指针变量

float  			* c；			//定义一个浮点型指针变量


## 指针变量怎么赋值？

指针变量存放的是地址值！

***你是什么类型的指针变量，就应该指向该类型变量的地址！***

## 给指针变量赋值？

~~~
int 	a=10；	//假设a的地址为0×2000
int		*p=&a；	//定义一个整型指针变量p，存放整形变量a的地址，此时p的值为0X2000
int 	c=*p；	//取地址所在内存中的内容。

tips：利用&运算符可以获取变量的内存地址。
~~~

![image-20210505150511348](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505150511.png)

![image-20210505150546590](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505150546.png)

![image-20210505150757782](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505150757.png)

# 19.野指针、空指针

一个是危险的，一个是什么都能指！



## 空类型指针--用于兼容不同类型的指针

void *



## 空类型指针的作用？

void * 可以指向任何类型的地址！

~~~
int a=10；
char b='A'；
float c=12.345；

void *pA=&a；//指向整型变量地址
void *pB=&b；//指向字符型变量地址
void *pC=&c；//指向浮点型变量地址
~~~

## 示例

~~~
#include <stdio.h>//系统头文件，包含了printf，scanf等系统函数的声明
void main()//系统主函数，整个程序的入口函数，这个是它的简写
{
//定义了3个变量
char  a='A'；
int b=10；
float c=1.234f；

//char*，int*，float*
//void *可以指向任何类型的变量的地址
void *pA=&a；
void *pB=&b；
void *pC=&c；
~~~

~~~
运行报错：错误，不允许使用不完整的类型
~~~

~~~
//需要强制转换后，才能使用
char *pAA=（char *）pA；
int *pBB=（int *）pB；
float *pCC=（float *）pC；

printf（"%c\n"，*pAA）；
printf（"%d\n"，*pBB）；
printf（"%f（n"，*pCC）；I
~~~

## void *的作用

~~~
#include <stdlib.h>///系统头文件，包含了malloc，free等系统函数的声明
~~~

![image-20210505151943018](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505151943.png)

malloc()返回 void *，任何类型的地址。所以前面加上（int *）强制转换。

~~~
//void*可以承接任何类型的地址，所以具有兼容性
int *p=（int *）malloc（4）；//malloc()可以分配任何类型的空间
int *p2=（char *）malloc（4）；
float *p3=（float *）malloc（4）；
~~~

## 什么是野指针？

定义：指向一个非法的或已销毁的内存的指针！
**危害：对系统造成不可预知的危害！**

## 为什么出现野指针？

### 1）指针变量没有被初始化，它缺省值是随机的，它会乱指一气。

~~~
char *p；//野指针，p的值是随机的*

tips：指针变量在创建的同时应当被初始化，要么将它设置为NULL，要么让它指向合法的内存。例如：
char *p= NULL； //#define NULL（（void*）0）
char *p=（char*）malloc（100）；
~~~



#### **错误示范：**

~~~
//随机定义一个指针变量，不初始化
int	*p4；
printf（"%p\n"，p4）；//乱的地址值
~~~





![image-20210505153055341](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505153055.png)

![image-20210505153035136](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505153035.png)

#### **正确示范**

 ~~~
#define NULL（（void*）0）
//随机定义一个指针变量，不初始化
int	*p4=NULL；
printf（"%p\n"，p4）；//乱的地址值
 ~~~



解决方法：给指针赋初值NULL！

~~~
#define NULL（（void*）0）
int *p=NULL；
printf("%p\n",NULL)
~~~

~~~
0000 0000//(16进制 显示，所以只有八位)。int 四个字节，32位（32个二进制）。
		//但是四个二进制等于一个十六进制。32/4=8。所以用十六进制表示，只展示8个数字（0-E）
~~~



### 2）指针p被free或delete之后，只是把指针所指的内存给释放掉，没有改变指针的值。此时p沦落为“野指针”。

#### 错误示例

这就好比你的亲戚搬家了，你手上还留着他的旧地址！

~~~
float *p3=（float *）malloc（4）；
*p3 =1.234f;


printf（"%p\n"，p3）；//打印p3指针
free（p3）；			//释放p3指针所指向的内存
printf（"%p\n"，p3）；//打印p3指针
~~~



![image-20210505154558361](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505154558.png)

**key**: 释放内存了，但是不会改变指针的值。此刻你再去访问p3的内存，事实上是非法访问！

 

#### 正确示例1

~~~
float *p3=（float *）malloc（4）；
*p3 =1.234f;


printf（"%p\n"，p3）；//打印p3指针
free（p3）；			//释放p3指针所指向的内存
printf（"%p\n"，p3）；//打印p3指针

printf("%f\n",*p3);  //通过结果，可以看出非法访问
~~~

![image-20210505155149840](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505155452.png)



~~~
float *p3=（float *）malloc（4）；
*p3 =1.234f;


printf（"%p\n"，p3）；//打印p3指针
free（p3）；			//释放p3指针所指向的内存

if (p3 !=NULL)
{
	p3=NULL;
}

printf（"%p\n"，p3）；//打印p3指针


~~~





#### 正确示例2

![image-20210505155338615](C:\Users\study\AppData\Roaming\Typora\typora-user-images\image-20210505155338615.png)

# 20.指针与数组

## 数组名本身就是一个指针（地址）！

~~~
#include <stdio.h>//系统头文件，包含了printf，scanf等系统函数的声明
void main()//系统主函数，整个程序的入口函数，这个是它的简写
{
int a[3]={1，2，3]；
printf（"%p\n"，a）；//数组名本来就是一个地址
}
~~~

![image-20210505160338594](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505160338.png)

![image-20210505160403086](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505160403.png)

![image-20210505160522516](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505160522.png)

~~~
#include <stdio.h>//系统头文件，包含了printf，scanf等系统函数的声明
void main()//系统主函数，整个程序的入口函数，这个是它的简写
{
int a[3]={1，2，3]；
printf（"%p  %p\n"，a, &a[0]）；//数组名本来就是一个地址
}
~~~

![image-20210505160645232](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505160645.png)

既然数组名是一个地址，那么则可以赋值给指针变量

int *p=a;

## 1.指针作操作数组一-------把指针当成数组名

### 正确写法

~~~
#include <stdio.h>//系统头文件，包含了printf，scanf等系统函数的声明
int main()//系统主函数，整个程序的入口函数，这个是它的简写
{
	int a[5] = { 1,2,3,4,5 };
	printf("%p  %p\n", a, &a[0]);//数组名本来就是一个地址


	int *p = a;
	//1.把指针变量当成数组名
	for (int i = 0; i < 5; ++i)
	{
		printf("%d", p[i] );//下标索引的方式访问
	}
}
~~~

![image-20210505163539969](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505163540.png)

### 错误写法

~~~
#include <stdio.h>//系统头文件，包含了printf，scanf等系统函数的声明
int main()//系统主函数，整个程序的入口函数，这个是它的简写
{
	int a[5] = { 1,2,3,4,5 };
	printf("%p  %p\n", a, &a[0]);//数组名本来就是一个地址


	int *p = a;
	//1.把指针变量当成数组名
	for (int i = 0; i < 5; ++i)
	{
		printf("%d", *p[i] );//下标索引的方式访问
	}
}
~~~

访问存在优先级，p[i]先结合，他是一个数。而不是一个指针。所以*数报错

![](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505164243.png)

## 2.指针作操作数组二-----指针+1或-1是向上或向下偏移 sizeof（int）个字节------(不会改变指针p的值)

### 正确写法

![image-20210505162302832](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505162303.png)



~~~
#include <stdio.h>//系统头文件，包含了printf，scanf等系统函数的声明
int main()//系统主函数，整个程序的入口函数，这个是它的简写
{
	int a[5] = { 1,2,3,4,5 };
	printf("%p  %p\n", a, &a[0]);//数组名本来就是一个地址


	int *p = a;
	//1.把指针变量当成数组名
	for (int i = 0; i < 5; ++i)
	{
		printf("%p \n", (p+i));//i相当于sizeof（int）
		printf("%d\n", *(p + i));
	}
}
~~~

![image-20210505170027354](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505170043.png)



### 本质上 printf("%d", p[i] );等价于 printf("%d", *（p+i) )；

## 3.指针作操作数组三-----指针++-----(会改变指针p的值)

~~~
for（int i=0；i<5；++i）
{
printf（"%d\n"，*p）；//取地址的内容
printf（"%p %p\n"，&a[i]，（p++））；//指针变量+1*sizeof（int），p++依然是一个地址
}
~~~

![image-20210505171002910](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505171003.png)



## key:数组名是一个常量，不可改变他的值，自然就不能++,即不能a=a+1

![image-20210505171317272](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505171317.png)

## 指针与数组的区别

![image-20210505171504213](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505171504.png)

## 指针型数组

![image-20210505171555734](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505171555.png)

## 指针型数组的定义

~~~
指针类型	数组名[N]
int*	a[5]；//整型指针数组
char*	b[5]；//字符型指针数组
float*	c[5]；//浮点型指针数组
~~~

**指针型数组，每个元素都是指针值！**

~~~
int	 a=10；
int  b[3]={1，2，3}；
int* c[3]={&a，b，&b[1]}；//数组名就是一个地址
~~~

![image-20210505172100021](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505172122.png)

![image-20210505172108983](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505172129.png)

# 21.指针与字符串

**字符串可以看成一个无名字符数组！**

## 字符串常量本身（无名数组）就是一个地址！

![image-20210505172342677](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505172342.png)

~~~
#include<stdio.h>//系统头文件，包含了printf，scanf等系统函数的声明
void main()//系统主函数，整个程序的入口函数，这个是它的简写
{
printf（"%p\n"，"hello"）；//字符串常量实际上就是一个首地址
}
~~~

![image-20210505172610894](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505172610.png)



`char *p=“hello"；`//**字符串可以看成一个无名字符数组！**,所以“hello”相当于数组名，相当于数组的首地址
给指针变量赋予字符串常量（字符数组，末尾自动加上字符'\0'）的首地址！

~~~
既然字符串常量可以看成一个无名数组！
#include<stdio.h>//系统头文件，包含了printf，scanf等系统函数的声明
void main()//系统主函数，整个程序的入口函数，这个是它的简写
{
//字符串常量
printf（"%p\n"，"hello"）；//字符串常量实际上就是一个首地址.	//"hello"后面自动带上'\0'有六位
printf("s","hello")//不会打印出'\0'，字符串读取到'\0'就自动停止，不再打印


//字符数组
char *p="hello"；
//给一个无名的常量区字符串，给了一个名字
//把“hello”的首地址赋给字符型指针变量

//1.指针作为数组名来访问字符串
for（int i=0；i<6；++i）	//"hello"后面自动带上'\0',有六位
{
	printf（"%c"，p[i]）；//p[i]相当于*(p+1)
	//这里的打印会强制打印出'\0'，如果i=8，还有继续在内存地址中搜索，继续打印
	
}
}
~~~

![image-20210505193835320](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505193835.png)

o与请之间有个空隙，那就是'\0'

~~~
//2.指针时刻改变p++(自加)
for（int i=0；i<6；++i）；
printf（"%c"，*（p++））；//指针p的值在发生变化，int *p2=p;
~~~

~~~
//既然字符串常量可以看成一个无名数组！
//3.数组指针*（p+i)
for(int i=0;i<5;i++)
{
printf("%c\n",*(p+i));
}
~~~

![image-20210505203146684](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505203146.png)

  

![image-20210505203254726](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505203254.png)

![image-20210505203303576](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505203303.png)

## tips：字符串常量的值不能改变！

![image-20210505203347329](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505203347.png)

~~~
char *p3=NULL；

p3="hello"；//把hello的首地址给p3
printf（"\n%p"，p3）；

p3="world"；//把world的首地址给p3，覆盖前一次的值
printf（"\n%p"，p3）；

//把p3的第二个元素值o改为0
p3[1]='0'；//错误，因为字符串是一个常量，不允许改变常量的值
~~~

# 22.指针与函数

指针可以调用函数哦！

## 函数名本身就是一个指针（地址）！

~~~
int sum（int a，int b）
{
return a+b；
}
函数名sum代表了函数(函数入口）的地址！
~~~



~~~
#include <stdio.h>//系统头文件，包含了printf，scanf等系统函数的声明

int sum（int a，int b）
{
return a+b；
}
void main()//系统主函数，整个程序的入口函数，这个是它的简写
{
//函数名就是函数的入口地址
printf（"%p\n"，sum）；
}
~~~



![image-20210505204702888](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505204702.png)

## 函数指针定义

返回值  （*指针变量名）（参数1、参数2..参数N）；

## 函数指针变量

![image-20210505205115993](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505205116.png)

~~~
#include <stdio.h>//系统头文件，包含了printf，scanf等系统函数的声明

int sum（int a，int b）
{
return a+b；
}

void main()//系统主函数，整个程序的入口函数，这个是它的简写
{
//函数名就是函数的入口地址
printf（"%p\n"，sum）；

//定义一个函数指针变量，必须与指向的函数形式保持一致
int (*pSum) (int a,int b);
//把函数地址赋给函数指针变量
pSum=sum;

}
~~~



## 函数指针使用

当成函数一样使用！
pSum（111，999）；

![image-20210505205511689](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505205511.png)

# 23.结构体

先思考一个问题：
一个学生有学号、姓名、年龄你会怎么描述？

小明的回答
int num；//学号

char name[20]；//姓名

int age；/年龄

===================================

那么问题来了：
现在有一干个学生，号、姓名、年龄，你会怎么来描述？

小明的回答1

![image-20210505205749255](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505205749.png)

小明的回答2

~~~
int num[1000]；//1000个学号

char name[1000][20]；//1000个姓名

int age[1000]；//1000个年龄
~~~

![image-20210505210009002](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505210009.png)

两个致命缺点：
1.各数组数据没有关联性，一旦某个数组数据错位，所有学生的信息全错了
2.代码冗余，一旦属性太多，将导致大量的变量定义，不利于维护。

## 1.什么是结构体（struct）？

是由一系列具有相同类型或不同类型的数据构成的数据集合。

![image-20210505210227132](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505210330.png)

![image-20210505210314359](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505210414.png)

![image-20210505210357185](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505210422.png)

Student是结构体类型，stus是结构体变量名

![image-20210505210435693](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505210435.png)



## 2.结构体的定义形式

​		在学生的登录记录表中，姓名应该为字符型、学号可以为整形或字符型，年龄应该为整形，性别应该为字符型，成绩可以整形或实型。显然不能用一个数组来存放这一组数据，因为数组各元素的类型和元素都必须一致。

​		为了定义结构，必须用struct语句。struct语句定义了一个包含多个成员的新的数据类型。

~~~
Struct 结构名
{
成员列表；
}变量名列表；
 
Struct stu
{
Int num;
Char name[20];
Char sex;
Float score;
}boy1,boy2;
~~~

## （1）先定义结构，再说明结构变量

~~~

struct stu
{
int num;
char name[20];
int age;
};
struct stu boy1,boy2;
 
例如：
#define STU struct stu
STU
{
int num;
char name[20];
int age;
};
STU boy1,boy2;
~~~



## （2）在定义结构类型的同时说明结构变量。

~~~
struct stu
{
int num;
char name[20];
int age;
}boy1,boy2;

~~~

## （3）直接说明结构变量

~~~
struct
{
int num;
char name[20];
int age;
}boy1,boy2;
~~~

## 3.**结构体嵌套**

首先定义一个date，由month（月），day（日），year（年）三个成员组成。在定义并说明变量boy1和boy2时，其中的成员birthday被说明为date结构类型。成员名可以与其他的变量同名，互不干扰。

~~~
Struct date
 
{
 
Int month；
 
Int day；
 
Int year；
 
}；
 
Struct {
 
Int num；
 
Char name[20];
 
Char sex;
 
Struct date birthday;
 
Float score;
 
}boy1,boy2;
~~~

![image-20210509221338316](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210509221338.png)



## 4.引用结构体变量中成员

结构体变量名.成员名
stu1.num；
**"."是成员（分量）运算符，它在所有的运算符中优先级最高。**

## （1）定义变量时整体初始化

Student stu1={10000，"xiaoming"，18}；

系统会把每个值按顺序赋给每个成员变量.

## （2）分别对每个成员赋值来初始化结构体

~~~
Student  stu2；

stu2.num=10001；
strcpy（stu2.name，"lihua"）；
//strcpy把含有['\0']结束符的字符串复制到另一个[地址空间],返回值的类型为char*。
stu2.age=18；
~~~

### 对比数组的初始化和赋值、结构体的初始化和赋值

## 5.代码展示

~~~
#include <stdio.h>
#include<string.h>//系统头文件，包含了strcpy，strlen等系统函数的声明
//定义一个学生结构体类型

struct Student 
{
int num；//学号
char name[20]；//姓名
int age；/年龄
};

void main()//系统主函数，整个程序的入口函数，这个是它的简写
{
//定义结构体变量stu1并初始化化
struct Student stu1={10000，"zhangshan"，18}；

//先定义结构体变量stu2，然后再赋值
struct Student stu2；
stu2.num=10001；
strcpy(stu2.name."lisi");
stu2.age=20;

printf（“学号：%d\n"，stu1.num）；
printf（"姓名：%s\n"，stu1.name）；
printf（"年龄：%d\n"，stu1.age）；
~~~

# 24.结构体数组

~~~
struct Student
{
int num；
char name[20]； 
int age；
}；
//学生结构体类型
~~~

![image-20210505213658420](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505213658.png)

## 结构体数组

与定义数组一样：
`结构体类型		数组名[N]；`

tips：数组每个元素都是一个结构体变量！

## 1.结构体在定义时同时初始化

![image-20210505213820503](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505213820.png)

![image-20210505214347487](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505214347.png)

## 2.结构体先定义、再赋值

![image-20210505214032575](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505214032.png)

![image-20210505214051873](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505214051.png)

## 结构体数组的遍历

~~~
for(int i=0;i<3;i++)
{
	Student s=stus[i]; 
	printf("%d,%s,%d\n",s. num,s.name,s.age);
}
~~~

![image-20210505214300455](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505214300.png)

![image-20210505214355928](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505214356.png)

# 25.结构体与指针

## 结构体指针的定义

~~~
指针类型
int   *			整型指针类型
char  *			字符型指针类型
float *			浮点型指针类型
结构体类型 *		 结构体指针类型
~~~

~~~
struct Student
{
int num；
char name[20]；
int age；
}；
//学生结构体类型
~~~

~~~
结构体类型	 * 变量名；
Student		* pStu；

~~~

## 结构体指针的赋值

~~~
结构体指针变量的赋值？
Student stu={100，“liling"，18}；
Student *pStu=&stu；
~~~

**tip：结构体指针指向结构体的地址！**

![image-20210505215133895](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505215133.png)

## 结构体指针变量访问成员

![image-20210505215251750](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505215251.png)

~~~
void main（）//系统主函数，整个程序的入口函数，这个是它的简写
{
//定义一个结构体变量并初始化
struct Student stu={10000，"zhangsan"，18}；

//定义一个结构体指针变量
struct Student *pStu=&stu；∥用结构体变量的地址赋值

//访问结构体成员
//结构体变量访问
printf（"学号：%d，姓名：%s，年龄：%d"，stu.num，stu.name，stu.age）；//.操作符
//结构体指针访问（pStu是指针）
printf（"学号：%d，姓名：%s，年龄：%d"，pStu->num，stu->name，stu->age）；//->操作符
~~~

![image-20210505215608461](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505215608.png)

# 26.结构体与链表

## 链表的定义

链表是一种非连续的，但是通过指针关联的存储结构。

![image-20210505215721949](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505215722.png)

![image-20210505215802198](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505215802.png)

![image-20210505215816747](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505215816.png)

~~~
struct Node 
{
int data；//数据
struct Node *next；//下个结构体地址
}；
//结构体类型
~~~

## 示例

写出一条有三个节点的链表，并且用Node *pHead做为头指针？

~~~
#include <stdio.h>//系统头文件，包含了printf，scanf等系统函数的声明
∥定义链表的结构体（火车车厢）
struct Node 
{
int data；//数据域（车厢里的货物）
struct Node *next；//指针域（车厢的挂钩）
}；


void main()//系统主函数，整个程序的入口函数，这个是它的简写
{
//先定义三节火车车厢并初始化
struct Node n1={60，NULL}；
struct Node n2={70，NULL}；
struct Node n3={80，NULL}；

//把每节车厢链接起来
n1.next=&n2；//把第一节与第二节链接
n2.next=&n3；//把第二节与第三节链接

//把头指针指向第一节车厢
struct Node *pHead=&n1；

//打印出这辆火车
while（pHead！=NULL）//pHead是指针，所以用->来指向元素
{
printf（"货物：%d"，pHead->data）；
pHead=pHead->next；//指针不断后移
}
~~~

~~~

~~~

![image-20210505220732807](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505220732.png)

# 27.共用体

一种节约空间的数据类型！

## 共用体定义

一个内存地址可以存储不同数据类型的类型！

![image-20210505220955512](C:\Users\study\AppData\Roaming\Typora\typora-user-images\image-20210505220955512.png)

![image-20210505221011366](C:\Users\study\AppData\Roaming\Typora\typora-user-images\image-20210505221011366.png)

union:联合、联盟

## 共用体初始化

![image-20210505221152555](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505221152.png)

int覆盖char，float覆盖int

## 共用体赋值

![image-20210505221328195](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505221328.png)

~~~
#include <stdio.h>//系统头文件，包含了printf，scanf等系统函数的声明
#include <string.h>

//定义一个共用体类型MyUgion
union MyUgion
{
char a[6]；
int b；
float c；
};

void main（）//系统主函数，整个程序的入口函数，这个是它的简写
{
//定义一个MyUnion共用体变量
union MyUnion u1；

strcpy（u1.a，"hello"）；
printf（"%s\n"，u1.a）；

u1.b=10；
printf（"%d\n"，u1.b）
printf（"%s\n"，u1.a）；

//u1.c=10.11f；
//printf("%f\n",u1.c);
~~~

![image-20210505221930737](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505221930.png)

此时u1.a的值消失，被u1.b覆盖

~~~
#include <stdio.h>//系统头文件，包含了printf，scanf等系统函数的声明
#include <string.h>

//定义一个共用体类型MyUgion
union MyUgion
{
char a[6]；
int b；
float c；
};

void main（）//系统主函数，整个程序的入口函数，这个是它的简写
{
//定义一个MyUnion共用体变量
union MyUnion u1；

strcpy（u1.a，"hello"）；
printf（"%s\n"，u1.a）；

u1.b=10；
printf（"%d\n"，u1.b）
printf（"%s\n"，u1.a）；

u1.c=10.11f；
printf("%f\n",u1.c);
~~~

![image-20210505222244106](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505222244.png)



![image-20210505222705894](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505222731.png)

![image-20210505222746729](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505222746.png)

共用体占用的内存应大于存储共用体中最大的成员！
printf（"%d\n"，sizeof（u1））；

~~~
union MyUgion
{
char a[6]；
int b；
float c；
};

printf（"%d\n"，sizeof（u1））；
~~~

输出结果：

char a[6]；--->8

char a[8]；--->8

char a[9]；--->12

## 结构体与共用体的区别

![image-20210505223339405](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505223339.png)

# 28.文件系统

文件系统，操作系统在磁盘上组织文件的方法！

## 什么是文件系统？

文件系统是操作系统用于明确磁盘或分区上的文件的方法和数据结构；即在磁盘上组织文件的方法。

一个分区或磁盘在作为文件系统使用前，需要初始化，并将记录数据结构写到磁盘上。这个过程就叫建立文件系统。
tips：新U盘为什么需要格式化？

![image-20210505223715008](C:\Users\study\AppData\Roaming\Typora\typora-user-images\image-20210505223715008.png)

## windows常见的文件系统？

![image-20210505224240459](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505224240.png)

## 文件的分类

![image-20210505223846250](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505223846.png)

# 29.文件的读写

## 文件操作方式

![image-20210505224155377](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505224155.png)

![image-20210505224325571](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505224325.png)

![image-20210505224347441](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210505224347.png)

## 文件指针的使用 --fopen打开文件

~~~
FILE *fp=fopen("test.txt","r")
if(fp!=NULL)
{
	printf("fopen成功\n");
}
else
{
	printf("fopen失败\n");
}
~~~

若当前目录下不存在此文件，（读取的是相对路径），会报错

~~~
FILE *fp=fopen("test.txt","w")
if(fp!=NULL)
{
	printf("fopen成功\n");
}
else
{
	printf("fopen失败\n");
}
~~~

"w"则不会报错，没有文件建立一个新的，如果有文件，删除后建立一个新的空白文件

![image-20210509180627779](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210509180627.png)

## 文件指针的使用 --fwrite写入数据--执行完后，指正移到数据末尾

![image-20210509180832414](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210509180832.png)

![image-20210509182227057](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210509182227.png)

![image-20210509182329518](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210509182329.png)

![image-20210509182318868](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210509182318.png)

## 文件指针的使用 --fread读数据

![image-20210509182555444](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210509182555.png)

## 文件指针的使用 --fseek文件指针重定位

![image-20210509182856239](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210509182856.png)

![image-20210509183052039](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210509183052.png)

![image-20210509183122355](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210509183122.png)

------

![image-20210509183151645](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210509183151.png)





![image-20210509200100325](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210509200100.png)

**对str[]初始化，这一百个元素全是\0**

![image-20210509183225618](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210509183225.png)

![image-20210509195747796](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210509195747.png)

**当读取到'\0'字符时，默认字符串的末尾，不再打印展示**

![image-20210509195824087](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210509195824.png)

## 文件指针的使用 --fclose文件的关闭

![image-20210509200442056](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210509200442.png)

![image-20210509200855152](https://cdn.jsdelivr.net/gh/littleRita/clounding@master/data/20210509200855.png)